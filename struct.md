
**Cтруктура C++ проекта:**
# Сложное определние
## Структура файлов

### Заголовочный файл (.h/.hpp) — **спецификация**
```cpp
// calculator.h
#ifndef CALCULATOR_H
#define CALCULATOR_H

// Декларации функций (что доступно)
int add(int a, int b);
int subtract(int a, int b);
int multiply(int a, int b);
double divide(int a, int b);

#endif // CALCULATOR_H
```

### Файл реализации (.cpp) — **реализация**
```cpp
// calculator.cpp
#include "calculator.h"

// Определения функций (как работает)
int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int multiply(int a, int b) {
    return a * b;
}

double divide(int a, int b) {
    if (b == 0) {
        return 0.0; // Обработка ошибки
    }
    return static_cast<double>(a) / b;
}
```

### Основной файл программы
```cpp
// main.cpp
#include <iostream>
#include "calculator.h"

int main() {
    int x = 10, y = 5;
    
    std::cout << "Addition: " << add(x, y) << std::endl;
    std::cout << "Division: " << divide(x, y) << std::endl;
    
    return 0;
}
```

## Принципы организации

### 1. **Разделение интерфейса и реализации**
- Заголовочный файл: публичный интерфейс
- Файл .cpp: приватная реализация

### 2. **Структура проекта**
```
project/
├── include/           # Публичные заголовки
│   └── calculator.h
├── src/              # Реализация
│   ├── calculator.cpp
│   └── main.cpp
└── README.md
```

### 3. **Защита от многократного включения**
```cpp
#pragma once  // Современный способ

// Или традиционный:
#ifndef UNIQUE_IDENTIFIER
#define UNIQUE_IDENTIFIER
// код
#endif
```

### 4. **Правила включения файлов**
```cpp
// В .cpp файлах:
#include "соответствующий_заголовок.h"  // Сначала свои
#include <стандартная_библиотека>       // Затем системные
```

## Преимущества

1. **Инкапсуляция** — скрытие реализации
2. **Модульность** — независимая компиляция
3. **Повторное использование** — один заголовок в нескольких проектах
4. **Упрощение сопровождения** — изменения в реализации не затрагивают интерфейс

## Пример использования

**Заголовочный файл определяет контракт, который реализуется в .cpp файле, а основной код использует этот контракт через включение заголовка.**


---
# Простое опрделение

## `menu.h` = меню в кафе
Тут только названия блюд и цена. **Не написано рецепт!**

```cpp
// Это меню на столе
// Только названия и цена

Бургер();      // ← Есть бургер, 200 руб
Пицца();       // ← Есть пицца, 350 руб
Кофе();        // ← Есть кофе, 150 руб
```

## `kitchen.cpp` = кухня
Тут уже **рецепты** как готовить каждое блюдо.

```cpp
#include "menu.h"  // Смотрим в меню

// Как готовить бургер:
void Бургер() {
    взять_булку();
    положить_котлету();
    добавить_сыр();
    поджарить();
}

// Как готовить пиццу:
void Пицца() {
    раскатать_тесто();
    намазать_соус();
    положить_начинку();
    испечь_в_печи();
}
```

## `customer.cpp` = посетитель
```cpp
#include "menu.h"  // Смотрю меню

int main() {
    // Вижу в меню - заказываю
    Бургер();  // ← Заказал бургер
    Кофе();    // ← Заказал кофе
    
    return 0;
}
```

## Итого:
- **menu.h** — **что можно заказать** (только названия)
- **kitchen.cpp** — **как готовить** (рецепты)
- **customer.cpp** — **я, который заказывает**
